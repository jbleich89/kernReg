
R version 3.1.0 (2014-04-10) -- "Spring Dance"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "kernReg"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "kernReg-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('kernReg')
Loading required package: lattice
Loading required package: kernlab
Loading required package: ICEbox
Loading required package: sfsmisc
Loading required package: doParallel
Loading required package: foreach
Loading required package: iterators
Loading required package: parallel
Welcome to kernReg v1.0 by Justin Bleich and Adam Kapelner

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("auto_select_best_kpclr_model")
> ### * auto_select_best_kpclr_model
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: auto_select_best_kpclr_model
> ### Title: Auto-Select Best KPCLR Model
> ### Aliases: auto_select_best_kpclr_model
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #first create classification data
> ##D X = matrix(rnorm(300), ncol = 4)
> ##D y = rbinom(300, 1, 0.5)
> ##D #now explore kernel models using the default kernel list
> ##D explore_kpclr_obj = explore_kpclr_models(X, y)
> ##D #now we plot to see how the models built on the training data performed on the validation data
> ##D plot(explore_kpclr_obj)
> ##D #we are comfortable with allowing the computer to decide which model is best based on
> ##D #the minimum cost-weighted error model which falls wthin a default range of the error ratio.
> ##D explore_kpclr_obj = auto_select_best_kpclr_model(explore_kpclr_obj)
> ##D #re-plotting shows a blue line indicating the favored model
> ##D plot(explore_kpclr_obj)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("auto_select_best_kpclr_model", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("auto_select_best_kpcr_model")
> ### * auto_select_best_kpcr_model
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: auto_select_best_kpcr_model
> ### Title: Auto-Select Best KPCR Model
> ### Aliases: auto_select_best_kpcr_model
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #first create data
> ##D X = matrix(rnorm(300), ncol = 4)
> ##D y = rnorm(300)
> ##D #now explore kernel models using the default kernel list
> ##D explore_kpcr_obj = explore_kpcr_models(X, y)
> ##D #now we plot to see how the models built on the training data performed on the validation data
> ##D plot(explore_kpcr_obj)
> ##D #we are comfortable with allowing the computer to decide which model is best based on lowest SSE
> ##D explore_kpcr_obj = auto_select_best_kpcr_model(explore_kpcr_obj)
> ##D #re-plotting shows a blue line indicating the favored model
> ##D plot(explore_kpcr_obj)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("auto_select_best_kpcr_model", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("build_final_kpclr_or_kpcr_model")
> ### * build_final_kpclr_or_kpcr_model
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: build_final_kpclr_or_kpcr_model
> ### Title: Create Final Kernel Model
> ### Aliases: build_final_kpclr_or_kpcr_model
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #This example is for regression, but it works the same for logistic regression.
> ##D #first create regression data
> ##D X = matrix(rnorm(300), ncol = 4)
> ##D y = rbinom(300, 1, 0.5)
> ##D #now explore kernel models using the default kernel list and misclassification costs
> ##D explore_kpcr_obj = explore_kpclr_models(X, y)
> ##D #now we plot to see how the models built on the training data performed on the validation data
> ##D plot(explore_kpcr_obj)
> ##D #suppose we choose the 2nd kernel and the 10th rho
> ##D explore_kpcr_obj = set_desired_model(explore_kpcr_obj, 2, 10)
> ##D #now we build this model using the training and validation data and assess
> ##D #out-of-sample performance by predicting on the test data
> ##D explore_kpcr_obj = eval_winning_lr_model_on_test_data(explore_kpcr_obj)
> ##D #show results to console
> ##D explore_kpcr_obj
> ##D #we build a model using all the data in [X, y] to provide to the user who will use
> ##D #it to predict on future cases. This model should perform slightly better than the
> ##D #out-of-sample test split prediction results printed to console above
> ##D model_for_future_prediction = build_final_kpclr_or_kpcr_model(explore_kpcr_obj)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("build_final_kpclr_or_kpcr_model", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("build_kpca_object")
> ### * build_kpca_object
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: build_kpca_object
> ### Title: Builds a Kernel PCA Object
> ### Aliases: build_kpca_object
> 
> ### ** Examples
> 
> #create a random predictor matrix with four predictors
> X = matrix(rnorm(100), ncol = 4)
> #build a KPCA object using the anova kernel with hyperparameters sigma = 0.1 and d = 3
> kpca_obj = build_kpca_object(X, "anova", c(0.1, 3))
> #display some information to the console
> kpca_obj
Kernel PCA: 25 x 25 matrix built with the "anova" kernel w/params
sigma = 0.1, degree = 3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("build_kpca_object", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eval_winning_lr_model_on_test_data")
> ### * eval_winning_lr_model_on_test_data
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eval_winning_lr_model_on_test_data
> ### Title: Evaluate Test Data
> ### Aliases: eval_winning_lr_model_on_test_data
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #first create binary classification data
> ##D X = matrix(rnorm(300), ncol = 4)
> ##D y = rbinom(300, 1, 0.5)
> ##D #now explore kernel models using the default kernel list and misclassification costs
> ##D explore_kpclr_obj = explore_kpclr_models(X, y)
> ##D #now we plot to see how the models built on the training data performed on the validation data
> ##D plot(explore_kpclr_obj)
> ##D #suppose we choose the 2nd kernel and the 10th rho
> ##D explore_kpclr_obj = set_desired_model(explore_kpclr_obj, 2, 10)
> ##D #we can re-plot to ensure the chosen model is properly marked with a vertical line
> ##D plot(explore_kpclr_obj)
> ##D #now we build this model using the training and validation data and assess
> ##D #out-of-sample performance by predicting on the test data
> ##D explore_kpclr_obj = eval_winning_lr_model_on_test_data(explore_kpclr_obj)
> ##D #show results to console
> ##D explore_kpclr_obj
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eval_winning_lr_model_on_test_data", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eval_winning_r_model_on_test_data")
> ### * eval_winning_r_model_on_test_data
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eval_winning_r_model_on_test_data
> ### Title: Evaluate Test Data
> ### Aliases: eval_winning_r_model_on_test_data
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #first create regression data
> ##D X = matrix(rnorm(300), ncol = 4)
> ##D y = rnorm(300)
> ##D #now explore kernel models using the default kernel list
> ##D explore_kpcr_obj = explore_kpcr_models(X, y)
> ##D #now we plot to see how the models built on the training data performed on the validation data
> ##D plot(explore_kpcr_obj)
> ##D #suppose we choose the 2nd kernel and the 10th rho
> ##D explore_kpcr_obj = set_desired_model(explore_kpcr_obj, 2, 10)
> ##D #we can re-plot to ensure the chosen model is properly marked with a vertical line
> ##D plot(explore_kpcr_obj)
> ##D #now we build this model using the training and validation data and assess
> ##D #out-of-sample performance by predicting on the test data
> ##D explore_kpcr_obj = eval_winning_r_model_on_test_data(explore_kpcr_obj)
> ##D #show results to console
> ##D explore_kpcr_obj
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eval_winning_r_model_on_test_data", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plot_kpca")
> ### * plot_kpca
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot_kpca
> ### Title: Plots the kernel matrix
> ### Aliases: plot_kpca
> 
> ### ** Examples
> 
> #create a random predictor matrix with four predictors
> X = matrix(rnorm(100), ncol = 4)
> #build a KPCA object using the anova kernel with hyperparameters sigma = 0.1 and d = 3
> kpca_obj = build_kpca_object(X, "anova", c(0.1, 3))
> #visualize the kernel
> plot_kpca(kpca_obj) #"plot(kpca_obj)" also works and is recommended
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot_kpca", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("predict.kpclr")
> ### * predict.kpclr
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: predict.kpclr
> ### Title: Predicts for new data
> ### Aliases: predict.kpclr
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #first create binary classification data
> ##D X = matrix(rnorm(300), ncol = 4)
> ##D y = rbinom(300, 1, 0.5)
> ##D #build a KPCA object using the anova kernel with hyperparameters sigma = 0.1 and d = 3
> ##D kpca_obj = build_kpca_object(X, "anova", c(0.1, 3))
> ##D #build a kpclr model using 75% of the variance in the kernel matrix and weights for 1:1 cost ratio
> ##D kpclr_mod = kpclr(kpca_obj, y, frac_var = 0.75, weights = weights_for_kpclr(y))
> ##D #create 10 new data records and forecast on the new data
> ##D x_star = matrix(rnorm(40), ncol = 4)
> ##D y_hat = predict(kpclr_mod, x_star)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("predict.kpclr", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("predict.kpcr")
> ### * predict.kpcr
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: predict.kpcr
> ### Title: Predicts for new data
> ### Aliases: predict.kpcr
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #first create regression data
> ##D X = matrix(rnorm(300), ncol = 4)
> ##D y = rnorm(300)
> ##D #build a KPCA object using the anova kernel with hyperparameters sigma = 0.1 and d = 3
> ##D kpca_obj = build_kpca_object(X, "anova", c(0.1, 3))
> ##D #build a kpcr model using 75% of the variance in the kernel matrix
> ##D kpcr_mod = kpclr(kpca_obj, y, frac_var = 0.75)
> ##D #create 10 new data records and forecast on the new data
> ##D x_star = matrix(rnorm(40), ncol = 4)
> ##D y_hat = predict(kpcr_mod, x_star)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("predict.kpcr", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("set_desired_model")
> ### * set_desired_model
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: set_desired_model
> ### Title: Sets Desired Model
> ### Aliases: set_desired_model
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #Note this is example is for classification, but it works the same for regression
> ##D #first create classification data
> ##D X = matrix(rnorm(300), ncol = 4)
> ##D y = rbinom(300, 1, 0.5)
> ##D #now explore kernel models using the default kernel list
> ##D explore_kpclr_obj = explore_kpclr_models(X, y)
> ##D #now we plot to see how the models built on the training data performed on the validation data
> ##D plot(explore_kpclr_obj)
> ##D #we believe that the third kernel and the 9th value of rho is the "best" model
> ##D explore_kpclr_obj = set_desired_model(explore_kpclr_obj,
> ##D 						winning_kernel_num = 3, winning_rho_num = 9)
> ##D #re-plotting shows a blue line indicating the model we just set
> ##D plot(explore_kpclr_obj)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("set_desired_model", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("weights_for_kpclr")
> ### * weights_for_kpclr
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: weights_for_kpclr
> ### Title: Creates weights for kpca logistic regression
> ### Aliases: weights_for_kpclr
> 
> ### ** Examples
> 
> y_train = c(rep(0, 100), rep(1, 200))
> weights = weights_for_kpclr(y_train)
> table(weights)
weights
0.75  1.5 
 200  100 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("weights_for_kpclr", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.11 0 1.11 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
